import json

import signatures
import utils


class TestJWT:
    """
    Contains JWT under test
    """

    def __init__(self):
        self.is_json = True
        self.header = {}
        self.payload = {}

    def get_payload(self):
        if self.is_json:
            return self.payload
        return self.payload['default']

    def set_payload(self, payload):
        if utils.is_dict(payload):
            self.payload = payload
        else:
            self.is_json = False
            self.payload = {"default": payload}

    @staticmethod
    def split_jwt(ser_token):
        return ser_token.split(".", 3)

    @staticmethod
    def deserialize(ser_token: str):
        """
        Builds a TestJWT from a serialized JWT representation
        :param ser_token: serialized token
        :return: TestJWT instance
        """
        tok1, tok2, sig = TestJWT.split_jwt(ser_token)
        head = utils.base64url_decode(tok1)
        payload = utils.base64url_decode(tok2)
        jwt = TestJWT()
        jwt.original_jwt = ser_token;

        # noinspection PyBroadException
        try:
            jwt.header = json.loads(head)
            jwt_payload = json.loads(payload)
            jwt.set_payload(jwt_payload)
        except:
            jwt.set_payload(utils.force_unicode(payload))
        return jwt

    def show_token(self):
        """
        Print token
        :return:
        """
        print("\nIs JSON: {}".format(self.is_json))
        print("\nToken header:")
        print(json.dumps(self.header, indent=4, ensure_ascii=True))
        for i in self.header:
            "-> {} = {}".format(i, self.header[i])

        print("\nToken payload:")
        if self.is_json:
            print(json.dumps(self.get_payload(), indent=4, ensure_ascii=True))
            for i in self.get_payload():
                print("-> {} = {}".format(i, self.get_payload()[i]))
        else:
            print(self.get_payload())

    def get_algorithm(self):
        return self.header['alg']

    def set_algorithm(self, new_alg):
        self.header['alg'] = new_alg

    @staticmethod
    def build_section(dict_section):
        """
        Builds a JWT section (header or payload) by properly encoding content.
        :param dict_section: JSON (dict) or plain text (str) content to be encoded
        :return: JWT encoded section
        """
        if utils.is_dict(dict_section):
            new_section = utils.base64url_encode(utils.force_bytes(json.dumps(dict_section, separators=(",", ":"))))
        else:
            new_section = utils.base64url_encode(utils.force_bytes(dict_section))
        return new_section

    def build_token_without_signature(self):
        return TestJWT.build_section(self.header) + utils.force_bytes('.') + TestJWT.build_section(self.payload)

    def build_token(self, key=None):
        content_to_sign = self.build_token_without_signature()
        return content_to_sign + utils.force_bytes('.') + signatures.sign(self.get_algorithm(), content_to_sign,
                                                                          key=key)

    def verify_signature(self, key, expected_sig):
        alg = self.header['alg']
        print("Verify signature using alg {}".format(alg))
        if alg is None:
            print("Signature algorithm not set")
            return False
        if str.capitalize(alg) == "NONE":
            return True
        alg = self.get_algorithm()
        return signatures.verify(alg, self.build_token_without_signature(), key, utils.force_bytes(expected_sig))

    def compute_signature(self, key):
        alg = self.get_algorithm()
        print("Computing signature using alg {}".format(alg))
        if alg is None:
            print("Signature algorithm not set")
            return False
        if str.capitalize(alg) == "NONE":
            return self.build_token_without_signature()
        # TODO reuse build_section
        content_to_sign = utils.base64url_encode(
            utils.force_bytes(json.dumps(self.header, separators=(",", ":")))) + utils.force_bytes(
            ".") + utils.base64url_encode(utils.force_bytes(json.dumps(self.payload, separators=(",", ":"))))
        return signatures.sign(alg, content_to_sign, key=key)
