import hashlib
import hmac
import json
import signatures

from jwt import utils


class TestJWT:
    """
    Contains JWT under test and related key material
    """

    def __init__(self):
        self.is_json = True
        self.header = {}
        self.payload = {}
        self.secret = ""
        self.original_jwt = ""

    def get_payload(self):
        if self.is_json:
            return self.payload
        return self.payload['default']

    def set_payload(self, payload):
        if TestJWT.is_string(payload):
            self.is_json = False
            self.payload = {"default": payload}
        else:
            self.payload = payload

    @staticmethod
    def is_string(text):
        if isinstance(text, dict):
            return False
        else:
            return True

    @staticmethod
    def split_jwt(ser_token):
        return ser_token.split(".", 3)

    @staticmethod
    def deserialize(ser_token):
        tok1, tok2, sig = TestJWT.split_jwt(ser_token)
        #print("header {}".format(tok1))
        #print("payload {}".format(tok2))
        #print("sig {}".format(sig))
        head = utils.base64url_decode(tok1)
        payload = utils.base64url_decode(tok2)
        jwt = TestJWT()
        jwt.original_jwt = ser_token;

        # noinspection PyBroadException
        try:
            jwt.header = json.loads(head)
            jwt_payload = json.loads(payload)
            jwt.set_payload(jwt_payload)
        except:
            jwt.set_payload(utils.force_unicode(payload))
        return jwt

    def show_token(self):
        print("\nIs JSON: {}".format(self.is_json))
        print("\nToken header:")
        print(json.dumps(self.header, indent=4, ensure_ascii=True))
        for i in self.header:
            "-> {} = {}".format(i, self.header[i])

        print("\nToken payload:")
        if self.is_json:
            print(json.dumps(self.get_payload(), indent=4, ensure_ascii=True))
            for i in self.get_payload():
                print("-> {} = {}".format(i, self.get_payload()[i]))
        else:
            print(self.get_payload())

    def set_secret(self, secret):
        self.secret = secret

    def get_algorithm(self):
        return self.header['alg']

    @staticmethod
    def build_section(dict_section):
        if TestJWT.is_string(dict_section):
            new_section = utils.base64url_encode(utils.force_bytes(dict_section))
        else:
            new_section = utils.base64url_encode(utils.force_bytes(json.dumps(dict_section, separators=(",", ":"))))
        return new_section

    def verify_signature(self, key, expected_sig):
        alg = self.header['alg']
        print("Verify signature using alg {}".format(alg))
        if alg is None:
            print("Signature algorithm not set")
            return False
        if str.capitalize(alg) == "NONE":
            return True
        alg = self.get_algorithm()
        return signatures.verify(alg, TestJWT.build_section(self.header) + utils.force_bytes('.') + TestJWT.build_section(self.payload), key, utils.force_bytes(expected_sig))

token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
#sig = "SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
#secret = "your-256-bit-secret"
tjwt = TestJWT.deserialize(token)
tjwt.show_token();
#tjwt.verify_signature(secret, sig)
