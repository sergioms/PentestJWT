import base64

import pem
import requests


def is_dict(text):
    if isinstance(text, dict):
        return True
    else:
        return False


def base64url_encode(input_bytes: bytes):
    return base64.urlsafe_b64encode(input_bytes).replace(b'=', b'')


def base64url_decode(input_str):
    if isinstance(input_str, str):
        input_str = input_str.encode('utf-8')

    # removes the base64 padding (=)
    padding = len(input_str) % 4
    if padding > 0:
        input_str += b'=' * (4 - padding)

    return base64.urlsafe_b64decode(input_str)


def force_unicode(value):
    if isinstance(value, bytes):
        return value.decode('utf-8')
    elif isinstance(value, str):
        return value.encode('utf-8')
    else:
        raise TypeError('Unexpected type {}'.format(type(value)))


def force_bytes(value):
    if isinstance(value, str):
        return value.encode('utf-8')
    elif isinstance(value, bytes):
        return value
    else:
        raise TypeError('Unexpected type {}'.format(type(value)))


def read_pem_file(file, debug=True):
    key = pem.parse_file(file)
    if debug:
        print('Read PEM:\n{}\n'.format(str(key)))
    return key[0].as_bytes()


def read_file(file: str, strip_newline=True, join_lines=False):
    """
    Reads a file
    :param file: Full path of the file to read. HTTP is used to retrieve file if parameter starts with https://
    :param strip_newline: If True, carriage returns (\n) are removed
    :param join_lines: If True, lines read are concatenated into a single line.
    :return: List of lines read
    """
    if file.lower().startswith("https://"):
        # TODO consider if keepends overlaps with strip_newline or join_lines
        key_list = requests.get(file, verify=True).text.splitlines()
    else:
        with open(file, "r") as f:
            key_list = f.readlines()
    if strip_newline:
        key_list = [x.replace('\n', '').strip() for x in key_list]
    if join_lines:
        return "".join(key_list)
    return key_list
